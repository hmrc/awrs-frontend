/*
 * Copyright 2018 HM Revenue & Customs
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package views

import builders.SessionBuilder
import controllers.{IndexController, routes}
import models.FormBundleStatus._
import models.{IndexStatus => _, _}
import org.jsoup.Jsoup
import org.jsoup.nodes.Element
import org.mockito.Mockito._
import play.api.i18n.Messages
import play.api.i18n.Messages.Implicits._
import play.api.libs.json.JsValue
import play.api.mvc.Result
import play.api.test.Helpers._
import services.DataCacheKeys._
import services._
import uk.gov.hmrc.http.cache.client.CacheMap
import utils.TestConstants._
import utils.TestUtil._
import utils.{AwrsNumberFormatter, AwrsUnitTestTraits}
import view_models._

import scala.concurrent.Future

class IndexViewTest extends AwrsUnitTestTraits with ServicesUnitTestFixture {

  override def beforeEach() = {
    super.beforeEach()
    reset(mockApplicationService)
  }

  object TestIndexController extends IndexController {
    override val authConnector = mockAuthConnector
    override val save4LaterService = TestSave4LaterService
    override val indexService = mockIndexService
    override val api9 = TestAPI9
    override val applicationService = mockApplicationService
  }

  object TestIndexControllerWithoutIndexMock extends IndexController {
    override val authConnector = mockAuthConnector
    override val save4LaterService = TestSave4LaterService
    override val indexService = IndexService
    override val api9 = TestAPI9
    override val applicationService = mockApplicationService
  }

  lazy val cachemap = CacheMap("", Map[String, JsValue]())
  lazy val noStatus = IndexViewModel(Nil)

  // N.B. this data is sufficient to test the following properties in the index-table.
  // 1) populate the section with the expected status
  // 2) populate the section name correctly when a count is given. e.g. (count) added for additional premises, directors, partners, group members and suppliers.
  // Since the IndexViewModel are generated by the IndexService, its validity is covered by the IndexService tests
  lazy val testIndexViewModel = (sectionStatus: IndexStatus, count: Int) =>
    IndexViewModel(
      List(
        SectionModel(businessDetailsName, routes.BusinessDetailsController.showBusinessDetails(isLinearMode = true).url, "awrs.index_page.business_details_text", sectionStatus),
        SectionModel(additionalBusinessPremisesName, routes.AdditionalPremisesController.showPremisePage(id = 1, isLinearMode = true, isNewRecord = true).url, "awrs.index_page.additional_premises_text", sectionStatus, count)
      )
    )

  "IndexView" must {

    "Index-table" should {
      def checkSectionStatus(testData: IndexViewModel)(implicit result: Future[Result]) = {
        val document = Jsoup.parse(contentAsString(result))
        testData.sectionModels.foreach {
          spec =>
            val sectionName = document.getElementById(spec.id).text()
            spec.size match {
              case Some(count) =>
                sectionName should include(Messages(spec.text, count))
                sectionName should include(count.toString)
              case _ =>
                sectionName should include(Messages(spec.text))

            }
            document.getElementById(s"${spec.id}_status").text() shouldBe Messages(spec.status.messagesKey)
        }
      }

      "Generated the Index-table as specified by the IndexViewModel" in {
        List(SectionComplete, SectionIncomplete, SectionEdited, SectionNotStarted).foreach {
          sectionStatus =>
            val testData = testIndexViewModel(sectionStatus, 10)
            implicit val result = showIndexPageAPI4(indexStatusModel = testData)
            checkSectionStatus(testData = testData)
        }
      }
    }

    "The call to action and unsubmitted changes banner" should {

      "In API4 jouney" should {
        "When the application is incomplete, the call to action button should be save_and_logout" in {
          val result = showIndexPageAPI4(allSectionComplete = false)
          val document = Jsoup.parse(contentAsString(result))
          document.getElementById("save_and_logout") should not be null
          document.getElementById("continue") shouldBe null
          document.getElementById("submit_changes") shouldBe null
        }

        "When the application is complete, the call to action button should be continue" in {
          val result = showIndexPageAPI4(allSectionComplete = true)
          val document = Jsoup.parse(contentAsString(result))
          document.getElementById("save_and_logout") shouldBe null
          document.getElementById("continue") should not be null
          document.getElementById("submit_changes") shouldBe null
        }
      }

      "In API5 jouney" should {
        "When the application is unmodified or incomplete, the call to action button should not be displayed" in {
          //N.B. the application can still be incomplete in an API5 if there are missing data from Etmp or changes made to the front end which required additional input
          List((false, false), (false, true), (true, false)).foreach {
            case (allSectionComplete, hasApplicationChanged) =>
              val result = showIndexPageAPI5(allSectionComplete = allSectionComplete, hasApplicationChanged = hasApplicationChanged)
              val document = Jsoup.parse(contentAsString(result))
              document.getElementById("save_and_logout") shouldBe null
              document.getElementById("continue") shouldBe null
              document.getElementById("submit_changes") shouldBe null
          }
        }

        "When the application is modified and complete, the call to action button should be submit_changes" in {
          val result = showIndexPageAPI5(allSectionComplete = true, hasApplicationChanged = true)
          val document = Jsoup.parse(contentAsString(result))
          document.getElementById("save_and_logout") shouldBe null
          document.getElementById("continue") shouldBe null
          document.getElementById("submit_changes") should not be null
        }

        "When the application is unmodified, do not display the unsubmitted changes banner" in {
          val result = showIndexPageAPI5(hasApplicationChanged = false)
          val document = Jsoup.parse(contentAsString(result))
          document.getElementById("changes-banner") shouldBe null
        }

        "When the application is modified, display the unsubmitted changes banner" in {
          val result = showIndexPageAPI5(hasApplicationChanged = true)
          val document = Jsoup.parse(contentAsString(result))
          document.getElementById("changes-banner") should not be null
        }
      }

    }

    "The status window" should {
      def checkElementsText(elementId: String, expected: String)(implicit result: Future[Result]): Unit = {
        val document = Jsoup.parse(contentAsString(result))
        document.getElementById(elementId).text() should include(expected)
      }

      def checkAwrsRefNo(shouldExists: Boolean)(implicit result: Future[Result]): Unit = {
        val document = Jsoup.parse(contentAsString(result))
        shouldExists match {
          case true =>
            document.getElementById("awrsRefNo") should not be null
            document.getElementById("awrsRefNo").text should include(AwrsNumberFormatter.format(testAWRSUtr))
          case false =>
            document.getElementById("awrsRefNo") shouldBe null
        }
      }

      case class LinkExpectations(href: String, text: String)

      def checkLinks(linkId: String, expectations: Option[LinkExpectations])(implicit result: Future[Result]): Unit = {
        val document = Jsoup.parse(contentAsString(result))
        val link: Element = document.getElementById(linkId)
        expectations match {
          case Some(exp) =>
            link.attr("href") should be(exp.href)
            link.toString should include(exp.href)
            link.text() shouldBe exp.text
          case None =>
            link shouldBe null
        }
      }

      def checkWithdrawLink(shouldExists: Boolean)(implicit result: Future[Result]) =
        checkLinks(linkId = "withdraw_link", shouldExists match {
          case true =>
            LinkExpectations(href = routes.WithdrawalController.showWithdrawalReasons().toString, text = Messages("awrs.index_page.withdraw_link"))
          case _ => None
        }
        )

      def checkDeRegLink(shouldExists: Boolean)(implicit result: Future[Result]) =
        checkLinks(linkId = "de_reg_page_link", shouldExists match {
          case true =>
            LinkExpectations(href = routes.DeRegistrationController.showReason().toString, text = Messages("awrs.index_page.de_registration_link"))
          case _ => None
        }
        )

      def checkViewApplicationLink(shouldExists: Boolean)(implicit result: Future[Result]) =
        checkLinks(linkId = "view-application", shouldExists match {
          case true =>
            LinkExpectations(href = routes.ViewApplicationController.show(false).toString, text = Messages("awrs.generic.print_application"))
          case _ => None
        }
        )

      "display application-status showing correct application status" in {
        {
          implicit val result = showIndexPageAPI4()
          checkElementsText(elementId = "application-status", expected = s"${Messages("awrs.index_page.draft")} ${Messages("awrs.index_page.application_status_text").toLowerCase}")
          checkAwrsRefNo(shouldExists = false)
          checkWithdrawLink(shouldExists = false)
          checkDeRegLink(shouldExists = false)
        }
        {
          implicit val result = showIndexPageAPI5(someStatus = testSubscriptionStatusTypePending)
          checkElementsText(elementId = "application-status", expected = s"${Messages("awrs.index_page.application_status_text")} ${Pending.name.toLowerCase}")
          checkAwrsRefNo(shouldExists = false)
          checkWithdrawLink(shouldExists = true)
          checkDeRegLink(shouldExists = false)
        }
        {
          implicit val result = showIndexPageAPI5(someStatus = testSubscriptionStatusTypeApproved)
          checkElementsText(elementId = "application-status", expected = s"${Messages("awrs.index_page.application_status_text")} ${Approved.name.toLowerCase}")
          checkAwrsRefNo(shouldExists = true)
          checkWithdrawLink(shouldExists = false)
          checkDeRegLink(shouldExists = true)
        }
        {
          implicit val result = showIndexPageAPI5(someStatus = testSubscriptionStatusTypeApprovedWithConditions)
          checkElementsText(elementId = "application-status", expected = s"${Messages("awrs.index_page.application_status_text")} ${ApprovedWithConditions.name.toLowerCase}")
          checkAwrsRefNo(shouldExists = true)
          checkWithdrawLink(shouldExists = false)
          checkDeRegLink(shouldExists = true)
        }
        // n.b. currently rejected users should simply be redirected, this will not be the case in these tests because
        // the status is not stored in the session. These tests are left in in-case this behaviour changes in the future.
        {
          implicit val result = showIndexPageAPI5(someStatus = testSubscriptionStatusTypeRejected)
          checkElementsText(elementId = "application-status", expected = Rejected.name.toLowerCase)
          checkAwrsRefNo(shouldExists = false)
          checkWithdrawLink(shouldExists = false)
          checkDeRegLink(shouldExists = false)
        }
      }

      "show one view link only when it is specifed" in {
        List(true, false).foreach {
          showLink =>
            implicit val result = showIndexPageAPI4(showOneViewLink = showLink)
            checkViewApplicationLink(shouldExists = showLink)
        }
      }

    }


  }

  private def showIndexPage(hasAwrs: Boolean,
                            hasApplicationChanged: Boolean,
                            allSectionComplete: Boolean,
                            showOneViewLink: Boolean,
                            businessName: String,
                            indexStatusModel: view_models.IndexViewModel,
                            someStatus: Option[SubscriptionStatusType]): Future[Result] = {
    setUser(hasAwrs = hasAwrs)
    setupMockSave4LaterService(
      fetchBusinessCustomerDetails = testReviewDetails,
      fetchAll = cachemap
    )
    setupMockAwrsAPI9(keyStore = someStatus, connector = DoNotConfigure)
    setupMockApplicationService(hasAPI5ApplicationChanged = hasApplicationChanged)
    setupMockIndexService(
      showOneViewLink = showOneViewLink,
      showContinueButton = allSectionComplete,
      getStatus = indexStatusModel
    )
    TestIndexController.showIndex.apply(SessionBuilder.buildRequestWithSession(userId, "SOP"))
  }


  private def showIndexPageAPI4(allSectionComplete: Boolean = false,
                                showOneViewLink: Boolean = false,
                                indexStatusModel: view_models.IndexViewModel = noStatus,
                                businessName: String = "My Business"): Future[Result] =
    showIndexPage(
      hasAwrs = false, // can never have awrs in api4
      hasApplicationChanged = false, // can never be modified in api4
      allSectionComplete = allSectionComplete,
      showOneViewLink = showOneViewLink,
      businessName = businessName,
      indexStatusModel = indexStatusModel,
      someStatus = None // status will always be draft in api4
    )

  private def showIndexPageAPI5(hasApplicationChanged: Boolean = false,
                                allSectionComplete: Boolean = false,
                                showOneViewLink: Boolean = false,
                                indexStatusModel: view_models.IndexViewModel = noStatus,
                                someStatus: Option[SubscriptionStatusType] = testSubscriptionStatusTypePending,
                                businessName: String = "My Business"
                               ): Future[Result] =
    showIndexPage(
      hasAwrs = true,
      hasApplicationChanged = hasApplicationChanged,
      allSectionComplete = allSectionComplete,
      showOneViewLink = showOneViewLink,
      businessName = businessName,
      indexStatusModel = indexStatusModel,
      someStatus = someStatus
    )

}
